THE DATA STRUCTURE NEEDS TO UNDERSTAND THE PRIORITIES OF THE ELEMENTS IT HOLDS
PRIORITY QUEUES HAVE A WHOLE NUMBER OF PRACTICAL USE CASES IN EVENT SIMULATION, THREAD SCHEDULING - REAL WORLD PROBLEMS LIKE HANDLING EMERGENCY ROOM CASES ETC.

INSERT ELEMENTS (ALONG WITH PRIORITY INFORMATION)
ACCESS THE HIGHEST PRIORITY ELEMENT
REMOVE THE HIGHEST PRIORITY ELEMENT

AN ARRAY OR A LIST - UNORDERED
INSERTION	CAN BE ANYWHERE IN THE LIST OR ARRAY - COMPLEXITY O(1)
ACCESS 		ACCESSING THE HIGHEST PRIORITY ELEMENT REQUIRES GOING THROUGH ALL ELEMENTS IN THE LIST - COMPLEXITY O(N)
REMOVE		REMOVING THE HIGHEST PRIORITY ELEMENT REQUIRES GOING THROUGH ALL ELEMENTS IN THE LIST - COMPLEXITY O(N)

AN ARRAY OR A LIST - ORDERED
INSERTION	REQUIRES FINDING THE RIGHT POSITION FOR THE ELEMENT BASED ON PRIORITY - COMPLEXITY O(N)
ACCESS 		ACCESSING THE HIGHEST PRIORITY ELEMENT IS THEN EASY - O(1)
REMOVE		REMOVING THE HIGHEST PRIORITY ELEMENT IS STRAIGHTFORWARD - COMPLEXITY O(1)


BALANCED BINARY SEARCH TREE
INSERTION	FOR A BALANCED BST THE WORST CASE IS- COMPLEXITY O(LG N)
ACCESS 		ACCESSING THE HIGHEST PRIORITY ELEMENT IS AGAIN O(LG N)
REMOVE		REMOVING THE HIGHEST PRIORITY ELEMENT IS O(LG N)


THE BINARY HEAP
INSERTION	INSERTING A NEW ELEMENT - COMPLEXITY O(LG N)
ACCESS 		ACCESSING THE HIGHEST PRIORITY ELEMENT IS FAST - O(1)
REMOVE		REMOVING THE HIGHEST PRIORITY ELEMENT IS O(LG N)







BINARY HEAP -
IF H IS THE HEIGHT OF THE TREE - THE LEAF NODES SHOULD ONLY BE AT LEVEL H OR H - 1
ALL NODES AT LEVEL H-1 HAVE TO BE FILLED BEFORE MOVING ON TO LEVEL H

MINIMUM HEAP -
THE NODE WITH THE SMALLEST VALUE SHOULD BE THE ROOT OF THE TREE
EVERY NODE VALUE SHOULD BE <= VALUE OF IT’S CHILDREN

MAXIMUM HEAP -
THE NODE WITH THE LARGEST VALUE SHOULD BE THE ROOT OF THE TREE
EVERY NODE VALUE SHOULD BE >= VALUE OF IT’S CHILDREN


HEAP IMPLEMENTATION -
THE OPERATIONS TYPICALLY PERFORMED ON A HEAP REQUIRES US TO:
1. TRAVERSE DOWNWARDS FROM THE ROOT TOWARDS THE LEAF NODES
2. TRAVERSE UPWARDS FROM THE LEAF NODES TOWARDS THE ROOT

ON A HEAP WE WANT TO BE ABLE TO:
GET LEFT CHILD
GET RIGHT CHILD
GET PARENT

HEAPS CAN BE REPRESENTED MUCH MORE EFFICIENTLY BY USING AN ARRAY AND HAVING AN IMPLICIT RELATIONSHIP TO DETERMINE THE PARENT, LEFT AND RIGHT CHILD OF A NODE

NODE AT INDEX: i
HAS A LEFT CHILD AT INDEX: 2i + 1
HAS A RIGHT CHILD AT INDEX: 2i + 2


HEAPIFY -
SIFT DOWN
AN ELEMENT IS IN THE WRONG POSITION WITH RESPECT TO OTHER ELEMENTS BELOW IT IN THE HEAP
IT HAS TO BE MOVED DOWNWARDS IN THE HEAP TOWARDS THE LEAF NODES TO FIND IT’S RIGHT POSITION

SIFT UP
AN ELEMENT IS IN THE WRONG POSITION WITH RESPECT TO OTHER ELEMENTS ABOVE IT IN THE HEAP
IT HAS TO BE MOVED UPWARDS IN THE HEAP TOWARDS THE ROOT NODE TO FIND IT’S RIGHT POSITION


HEAP -
constructor for array
is full
is empty
swap
get element at index
getparent
getrighchild
getleftchild

max/min HEAP-
SIFT DOWN
SIFT UP
REMOVE HIGHEST PRIORITY   [add last element as top]  [heap empty exception]
INSERT  heapfullexception


questions -
GET MAX ELEMENT IN MIN HEAP
FIND THE K LARGEST ELEMENTS IN A STREAM




//ArrayDeque<Integer>
peekLast()
peekFirst()
removeFirst()
removeFirst()
